name: Docker Manifest Builder

on:
  repository_dispatch:
    types: [docker-manifest-check]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to check and build manifest for'
        required: true
        default: ''
      wait_for_builds:
        description: 'Wait for builds to complete'
        required: false
        default: 'true'
        type: boolean

jobs:
  check-build-status:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    outputs:
      amd64-status: ${{ steps.check.outputs.amd64-status }}
      arm64-status: ${{ steps.check.outputs.arm64-status }}
      version: ${{ steps.check.outputs.version }}
      ready: ${{ steps.check.outputs.ready }}

    steps:
      - name: Wait for builds to complete
        id: check
        run: |
          # Simpler approach - use environment information directly
          # Set default values
          AMD64_STATUS="pending"
          ARM64_STATUS="pending"
          VERSION=""
          READY="false"
          WAIT_TIME=30 # Maximum wait time in minutes
          INTERVAL=60  # Check interval in seconds
          MAX_ATTEMPTS=$((WAIT_TIME * 60 / INTERVAL))
          CURRENT_ATTEMPT=0
          WAIT_FOR_BUILDS="true"
          
          # Determine if we should wait for builds
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            WAIT_FOR_BUILDS="${{ github.event.inputs.wait_for_builds }}"
            if [ -n "${{ github.event.inputs.version }}" ]; then
              VERSION="${{ github.event.inputs.version }}"
            fi
          fi

          # Set values based on the current event
          echo "Event name: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            echo "Event action: ${{ github.event.action }}"
            echo "Client payload version: ${{ github.event.client_payload.version }}"
          fi
          
          # Create build status directory
          mkdir -p /tmp/clickndebrid-docker-builds
          AMD64_FILE="/tmp/clickndebrid-docker-builds/AMD64_DONE"
          ARM64_FILE="/tmp/clickndebrid-docker-builds/ARM64_DONE"
          VERSION_FILE="/tmp/clickndebrid-docker-builds/VERSION.txt"
          
          # Debug what's in the /tmp directory
          echo "Contents of /tmp/clickndebrid-docker-builds:"
          ls -la /tmp/clickndebrid-docker-builds/ || echo "Directory not accessible"
          
          # Repository dispatch handling
          if [ "${{ github.event_name }}" == "repository_dispatch" ]; then
            if [ -n "${{ github.event.client_payload.version }}" ]; then
              # Set version from the event payload
              VERSION="${{ github.event.client_payload.version }}"
              
              # Save it to the VERSION file if not already there
              if [ ! -f "$VERSION_FILE" ]; then
                echo "$VERSION" > "$VERSION_FILE"
                echo "Created VERSION file with: $VERSION"
              else
                echo "VERSION file already exists with: $(cat $VERSION_FILE)"
                # Update it if different
                if [ "$(cat $VERSION_FILE)" != "$VERSION" ]; then
                  echo "Updating VERSION file to: $VERSION"
                  echo "$VERSION" > "$VERSION_FILE"
                fi
              fi
            elif [ -f "$VERSION_FILE" ]; then
              VERSION=$(cat "$VERSION_FILE")
              echo "Using VERSION from file: $VERSION (no payload version)"
            fi
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ github.event.inputs.version }}" ]; then
            # For workflow_dispatch, use the input version
            VERSION="${{ github.event.inputs.version }}"
            echo "$VERSION" > "$VERSION_FILE"
            echo "Created VERSION file with input: $VERSION"
          elif [ -f "$VERSION_FILE" ]; then
            # Fall back to existing VERSION file
            VERSION=$(cat "$VERSION_FILE")
            echo "Using VERSION from existing file: $VERSION"
          fi
          
          # Print AMD64 and ARM64 status
          if [ -f "$AMD64_FILE" ]; then
            echo "AMD64 status file exists with version: $(cat $AMD64_FILE)"
          else
            echo "AMD64 status file does not exist"
          fi
          
          if [ -f "$ARM64_FILE" ]; then
            echo "ARM64 status file exists with version: $(cat $ARM64_FILE)"
          else
            echo "ARM64 status file does not exist"
          fi
          
          if [ -z "$VERSION" ]; then
            echo "No version specified, cannot proceed"
            echo "version=" >> $GITHUB_OUTPUT
            echo "ready=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Wait-and-check loop
          while [ $CURRENT_ATTEMPT -lt $MAX_ATTEMPTS ]; do
            # Check if all builds are complete
            if [ -f "$AMD64_FILE" ]; then
              AMD64_STATUS="success"
              AMD64_VERSION=$(cat "$AMD64_FILE")
              echo "AMD64 build is complete (version: $AMD64_VERSION)"
            else
              echo "AMD64 build is not complete"
            fi

            if [ -f "$ARM64_FILE" ]; then
              ARM64_STATUS="success"
              ARM64_VERSION=$(cat "$ARM64_FILE")
              echo "ARM64 build is complete (version: $ARM64_VERSION)"
            else
              echo "ARM64 build is not complete"
            fi
            
            # Determine if we're ready to build the manifest
            if [ "$AMD64_STATUS" == "success" ] && [ "$ARM64_STATUS" == "success" ]; then
              echo "Both architectures are ready for version $VERSION, proceeding with manifest creation"
              READY="true"
              break
            fi
            
            # If not waiting, break immediately
            if [ "$WAIT_FOR_BUILDS" != "true" ]; then
              echo "Not waiting for builds, current status:"
              echo "AMD64: $AMD64_STATUS, ARM64: $ARM64_STATUS"
              break
            fi
            
            # Increment attempt counter and check if we've exceeded max wait time
            CURRENT_ATTEMPT=$((CURRENT_ATTEMPT+1))
            if [ $CURRENT_ATTEMPT -ge $MAX_ATTEMPTS ]; then
              echo "Reached maximum wait time ($WAIT_TIME minutes), giving up"
              break
            fi
            
            # Wait before next check
            REMAINING_MINS=$(( (MAX_ATTEMPTS - CURRENT_ATTEMPT) * INTERVAL / 60 ))
            echo "Waiting $INTERVAL seconds before next check (will keep checking for $REMAINING_MINS more minutes)..."
            sleep $INTERVAL
          done
          
          # Set outputs for job conditions
          echo "amd64-status=$AMD64_STATUS" >> $GITHUB_OUTPUT
          echo "arm64-status=$ARM64_STATUS" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ready=$READY" >> $GITHUB_OUTPUT
          
          # If we succeeded, clean up status files
          if [ "$READY" == "true" ]; then
            # Clean up the status files for the next build
            if [ -f "$AMD64_FILE" ] && [ -f "$ARM64_FILE" ]; then
              rm -f "$AMD64_FILE" "$ARM64_FILE" 
              if [ -f "/tmp/clickndebrid-docker-builds/VERSION.txt" ]; then
                rm -f "/tmp/clickndebrid-docker-builds/VERSION.txt"
              fi
              echo "Reset build status for next version"
            fi
          else
            echo "Not all conditions met, manifest creation may be skipped"
            
            # Show what's missing
            if [ "$AMD64_STATUS" != "success" ]; then
              echo "AMD64 build not complete"
            fi
            if [ "$ARM64_STATUS" != "success" ]; then
              echo "ARM64 build not complete"
            fi
            if [ -z "$VERSION" ]; then
              echo "No version specified"
            fi
          fi

  create-manifest:
    needs: check-build-status
    if: needs.check-build-status.outputs.ready == 'true'
    runs-on: ubuntu-latest
    permissions:
      packages: write

    steps:
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set lowercase repository name
        run: |
          REPO=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          echo "REPO=${REPO}" >> $GITHUB_ENV
          VERSION="${{ needs.check-build-status.outputs.version }}"
          VERSION_NO_V="${VERSION#v}"
          echo "VERSION=${VERSION}" >> $GITHUB_ENV
          echo "VERSION_NO_V=${VERSION_NO_V}" >> $GITHUB_ENV
          
          # Debug information
          echo "Ready to create manifest: ${{ needs.check-build-status.outputs.ready }}"
          echo "AMD64 status: ${{ needs.check-build-status.outputs.amd64-status }}"
          echo "ARM64 status: ${{ needs.check-build-status.outputs.arm64-status }}"
          echo "Version: ${{ needs.check-build-status.outputs.version }}"

      - name: Create and push Docker manifest
        run: |
          # Enable Docker CLI experimental features
          export DOCKER_CLI_EXPERIMENTAL=enabled
          
          # Verify that images exist before creating the manifest
          verify_image_exists() {
            local IMAGE_TAG=$1
            echo "Verifying image exists: ghcr.io/${REPO}:${IMAGE_TAG}"
            
              # First check if the image exists locally
            if docker image inspect ghcr.io/${REPO}:${IMAGE_TAG} &>/dev/null; then
              echo "✅ Image exists locally: ghcr.io/${REPO}:${IMAGE_TAG}"
              return 0
            else
              echo "Image not found locally, attempting to pull..."
              # Try to pull the image
              if docker pull ghcr.io/${REPO}:${IMAGE_TAG}; then
                echo "✅ Image pulled successfully: ghcr.io/${REPO}:${IMAGE_TAG}"
                return 0
              else
                echo "❌ Image does not exist or couldn't be pulled: ghcr.io/${REPO}:${IMAGE_TAG}"
                
                # List available images in the registry for debugging
                echo "Available images in the registry:"
                TOKEN=$(echo $GITHUB_TOKEN | docker login ghcr.io -u $GITHUB_ACTOR --password-stdin 2>&1 | grep -o 'Login Succeeded' || echo "Login Failed")
                
                if [ "$TOKEN" == "Login Succeeded" ]; then
                  echo "Listing available tags for ${REPO}..."
                  curl -s -H "Authorization: Bearer $(echo $GITHUB_TOKEN)" https://ghcr.io/v2/${REPO}/tags/list | grep -o '"tags":\[[^]]*\]' || echo "No tags found or access denied"
                else
                  echo "Failed to authenticate with registry"
                fi
                
                return 1
              fi
            fi
          }

          # Create function for creating and pushing manifests with retries
          create_and_push_manifest() {
            local TAG=$1
            local AMD64_TAG=$2
            local ARM64_TAG=$3
            local MAX_RETRIES=5
            local RETRY=0
            local SUCCESS=false
            
            echo "Verifying both architecture images exist..."
            
            # Verify both images exist
            if ! verify_image_exists "$AMD64_TAG"; then
              echo "AMD64 image not found, cannot create manifest"
              return 1
            fi
            
            if ! verify_image_exists "$ARM64_TAG"; then
              echo "ARM64 image not found, cannot create manifest"
              return 1
            fi
            
            echo "Creating manifest for ${TAG}..."
            
            # List the images that will be used for manifest
            echo "Images that will be used for manifest:"
            echo " - ghcr.io/${REPO}:${AMD64_TAG} (AMD64)"
            echo " - ghcr.io/${REPO}:${ARM64_TAG} (ARM64)"
            
            while [ $RETRY -lt $MAX_RETRIES ] && [ "$SUCCESS" = "false" ]; do
              if docker manifest create --insecure "ghcr.io/${REPO}:${TAG}" \
                "ghcr.io/${REPO}:${AMD64_TAG}" \
                "ghcr.io/${REPO}:${ARM64_TAG}"; then
                
                # Add platform annotations
                docker manifest annotate "ghcr.io/${REPO}:${TAG}" \
                  "ghcr.io/${REPO}:${AMD64_TAG}" --os linux --arch amd64
                  
                docker manifest annotate "ghcr.io/${REPO}:${TAG}" \
                  "ghcr.io/${REPO}:${ARM64_TAG}" --os linux --arch arm64
                
                echo "Manifest for ${TAG} created successfully, now pushing..."
                
                # Push with retry
                PUSH_RETRY=0
                PUSH_SUCCESS=false
                
                while [ $PUSH_RETRY -lt $MAX_RETRIES ] && [ "$PUSH_SUCCESS" = "false" ]; do
                  if docker manifest push --insecure "ghcr.io/${REPO}:${TAG}"; then
                    PUSH_SUCCESS=true
                    SUCCESS=true
                    echo "Successfully pushed manifest for ${TAG}"
                  else
                    PUSH_RETRY=$((PUSH_RETRY+1))
                    if [ $PUSH_RETRY -lt $MAX_RETRIES ]; then
                      echo "Push attempt $PUSH_RETRY failed, retrying in 5 seconds..."
                      sleep 5
                    else
                      echo "Failed to push manifest after $MAX_RETRIES attempts"
                    fi
                  fi
                done
              else
                RETRY=$((RETRY+1))
                if [ $RETRY -lt $MAX_RETRIES ]; then
                  echo "Create attempt $RETRY failed, retrying in 5 seconds..."
                  sleep 5
                else
                  echo "Failed to create manifest after $MAX_RETRIES attempts"
                  echo "The images might not be available or there could be an issue with the registry."
                  # List available tags
                  echo "Available tags for ${REPO}:"
                  docker images "ghcr.io/${REPO}*"
                fi
              fi
            done
            
            if [ "$SUCCESS" = "true" ]; then
              return 0
            else
              return 1
            fi
          }

          # Create manifests for all tag formats
          echo "Creating manifest for version without v prefix: $VERSION_NO_V"
          create_and_push_manifest "$VERSION_NO_V" "${VERSION_NO_V}-amd64" "${VERSION_NO_V}-arm64" || echo "Failed to create manifest for $VERSION_NO_V, continuing..."

          # Only create manifest with v prefix if original version had v prefix
          if [[ "$VERSION" == v* ]]; then
            echo "Creating manifest for version with v prefix: $VERSION"
            create_and_push_manifest "$VERSION" "${VERSION}-amd64" "${VERSION}-arm64" || echo "Failed to create manifest for $VERSION, continuing..."
          fi

          # Create latest manifest
          echo "Creating manifest for latest"
          create_and_push_manifest "latest" "latest-amd64" "latest-arm64" || echo "Failed to create manifest for latest, continuing..."

          echo "Docker manifest creation completed"
